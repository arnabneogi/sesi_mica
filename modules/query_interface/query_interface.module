<?php
define( "ORIGINAL_FORM", false );
/**
 * Changes the look and feel of the mica query screen
 * Implements hook form_FORM_ID_alter
 * 
 * @param type $form
 * @param type $form_state
 * @param type $form_id 
 */
function query_interface_form_mica_query_edit_form_alter(&$form, $form_state, $form_id) {
    if( ORIGINAL_FORM )
        return $form;  
    
    // Make sure the name field is filled (as it is required within mica)
    // and the complete box with metainformation is hidden from the user
    if( array_key_exists( "general", $form ) ) {
        // Add the name and description hidden field to the form itself
        $nameElement = $form[ "general" ][ "name" ];
        $nameElement[ "#weight" ] = 1;
        $nameElement[ "#type" ] = "hidden";
        
        // Set a default value for the name of the query.
        // This is needed because the name field is required
        if( !$nameElement[ "#default_value" ] ) 
            $nameElement[ "#default_value" ] = "Query " . mktime() . "." . rand(0,10000);
        
        $descriptionElement = $form[ "general" ][ "description" ];
        $descriptionElement[ "#type" ] = "hidden";
        
        // Remove the fieldset with name, description etc.
        unset( $form[ "general" ] );
        
        // Add fields to the form itself
        $form[ "name" ] = $nameElement;
        $form[ "description" ] = $descriptionElement;
    }
    
    // By default, show a list of all variables, with the possibility to add
    // and remove constraints for the variable.
    // First remove the add-term box, if it exists
    $unselected_variables = array();
    if( array_key_exists( "add-term", $form ) ) {
        // Find a set of variables not selected before
        $unselected_variables = $form[ "add-term" ][ "variables" ][ "#options" ];

        // Hide the variables select option from the screen
        // We also add an id attribute, so we can fill the value
        $form[ "add-term" ][ "#description" ] = "";
        $form[ "add-term" ][ "variables" ][ "#type" ] = "hidden";
        $form[ "add-term" ][ "variables" ][ "#attributes" ] = array( "id" => "edit-variables" );
        unset( $form[ "add-term" ][ "add-variable" ] );
        
        // Make sure the variables input field has all options that are available
        // Otherwise, the validation of the form may break
        if( !array_key_exists( "#options", $form[ "add-term" ][ "variables" ] ) ) {
            $form[ "add-term" ][ "variables" ][ "#options" ] = array();
        }
        if( array_key_exists( "list", $form ) ) {
            foreach( $form[ "list" ] as $key => $element ) {
                if( is_numeric( $key ) ) {
                    $form[ "add-term" ][ "variables" ][ "#options" ][ $element[ "vid" ][ "#value" ] ] = $element[ "title" ][ "#markup" ];
                }
            } 
        }
        
        // Set default value, as it is needed to validate the form
        $validIds = array_keys( $form[ "add-term" ][ "variables" ][ "#options" ] );
        $form[ "add-term" ][ "variables" ][ "#value" ] = $validIds[ 0 ];
    }
    
    // Hide all weight elements
    foreach( $form[ "list" ] as $key => $element ) {
        if( is_numeric( $key ) ) {
            $form[ "list" ][ $key ][ "weight" ][ "#type" ] = "hidden";
        }
    }
    
    // Add these notselected variables to the list
    $form[ "not-selected" ] = array();
    foreach( $unselected_variables as $vid => $variableTitle ) {
        $form[ "not-selected" ][] = array(
          'title' => array(
            '#markup' => $variableTitle,
          ),
          'expression' => array(
            '#type' => 'hidden',
            '#value' => $variableTitle,
          ),
          'weight' => array(
            '#type' => 'hidden',
            '#delta' => 1,
            '#default_value' => 0,
          ),
          'id' => array(
            '#type' => 'hidden',
            '#value' => 0,
          ),
          'vid' => array(
            '#type' => 'hidden',
            '#value' => $vid,
          ),
        );
    }
    
    // Types of rows in the form:
    //   The key 'list' defines the list of variables for which a constraint has been
    //       added. Every such row should have 2 buttons, 'edit' and 'delete'. Because
    //       of the way mica has been programmed, the remove button must be inside
    //       the 'remove-term' element. That is what the value denotes.
    //   The key 'not-selected' defines the list of variables that can still be selected.
    //       the buttons for these variables (only add button) will be added to 
    //       an element with the name 'buttons-not-selected
    $rowTypes = array( "list" => "remove-term", "not-selected" => "buttons-not-selected" );
    foreach( $rowTypes as $type => $buttonKey ) {
        $form[ $buttonKey ] = array();
        if( array_key_exists( $type, $form ) ) {
            // Make sure the buttons for all variables exist in the form
            // That is needed for drupal to handle them later on.
            // They are put in the right position in the sesi_mica_query_edit_form method
            foreach( $form[ $type ] as $key => $variable ) {
                if( !is_numeric( $key ) ) {
                    continue;
                }

                $vid = $variable["vid"][ "#value" ];
                $alreadySelected = ( $type == "list" );

                if( $alreadySelected ) {
                    $buttons = array( 
                        "edit" => array(
                            "#type" => "submit",
                            "#name" => "edit-variable-" . $vid,
                            "#value" => "Edit",
                            "#vid" => $vid
                        ),
                        "delete" => array(
                            "#type" => "submit",
                            "#name" => "delete-variable-" . $vid,
                            "#value" => "Delete",
                            "#parents" => array( "remove-term" ),
                            "#vid" => $vid,
                        )
                    );
                } else {
                    $buttons = array( 
                        "add" => array(
                            "#type" => "submit",
                            "#value" => "Add",
                            "#name" => "add-variable-" . $vid,
                            "#vid" => $vid,
                            "#parents" => array( "add-variable" ),
                            "#attributes" => array( "onClick" => "jQuery('#edit-variables').val(" . $vid . "); return true;" )
                        )
                    );
                }

                $form[ $buttonKey ][ $key ] = $buttons;
            }
        }
    }

    
    return $form;
}

//function query_interface_theme_registry_alter(&$theme_registry) {
//	if (!empty($theme_registry['mica_query_edit_form']['function'])) {
//		$theme_registry['mica_query_edit_form']['function'] = 'sesi_mica_query_edit_form';
//	}
//}

function sesi_mica_query_edit_form($variables) {
    if( ORIGINAL_FORM )
        return theme_mica_query_edit_form($variables);
    
    $form = $variables['form'];
    
    drupal_add_tabledrag('draggabledemo-sort', 'order', 'sibling', 'sort');
    $header = array(t('Query Term'), t( 'Expression' ), t('Operations'));

    // Create the table rows on the screen
    $rows = array();

    // Types of rows in the form:
    //   The key 'list' defines the list of variables for which a constraint has been
    //       added. Every such row should have 2 buttons, 'edit' and 'delete'. Because
    //       of the way mica has been programmed, the remove button must be inside
    //       the 'remove-term' element. That is what the value denotes.
    //   The key 'not-selected' defines the list of variables that can still be selected.
    //       the buttons for these variables (only add button) will be added to 
    //       an element with the name 'buttons-not-selected
    $rowTypes = array( "list" => "remove-term", "not-selected" => "buttons-not-selected" );
    
    foreach( $rowTypes as $type => $buttonKey ) {
        if( array_key_exists( $type, $form ) ) {
            foreach (element_children($form[$type]) as $key) {
                $variable = $form[$type][$key];
                $alreadySelected = ( $type == "list" );
                $row = array();

                // title
                $row[] = drupal_render($variable['title']);

                // weight and hidden fields
                $weightElement = $variable['weight'];
                $weightElement[ "#type" ] = "hidden";
                $row_rendered = drupal_render($weightElement);
                if (array_key_exists('expression', $variable)) {
                  $row_rendered .= drupal_render($variable['expression']);
                }

                // Add hidden elements to store id and vid for this element
                // only if it has been added already, not if the item is here to show the 'add' button
                if( $alreadySelected ) {
                    $row_rendered .= drupal_render($variable['id']) . drupal_render($variable['vid']);
                }

                $row[] = $row_rendered;

                // Add operations
                if( array_key_exists( $buttonKey, $form ) && array_key_exists( $key, $form[ $buttonKey ] ) ) {
                    $row[] = drupal_render_children( $form[ $buttonKey ][ $key ] );
                } else {
                    $row[] = "";
                }

                $rows[] = array('data' => $row, 'class' => array('draggable')); //note the difference between $row and $rows
            }
        }
    }
  
  $output = theme('table',
    array(
      'header' => $header,
      'rows' => $rows,
      'empty' => t('No query term found'),
      'attributes' => array('id' => 'draggabledemo-sort')
    )
  );

  $output .= drupal_render_children($form, array('cross'));
  $output .= drupal_render_children($form, array('actions'));

  // add form hidden items, otherwise submit and validate will be ignored
  $fieldsAlreadyPrinted = array( 'cross', 'actions', 'list', 'remove-term', 'not-selected', 'buttons-list', 'buttons-not-selected' );
  foreach (element_children($form) as $key) {
      if( !in_array( $key, $fieldsAlreadyPrinted ) )
        $output .= drupal_render_children($form, array($key));
  }

  return $output;
}
