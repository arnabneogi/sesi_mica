<?php

include 'query_subscription.email.inc';

// implements hook_entity_info
function query_subscription_entity_info() {
  $info = array();
  $info['query_subscription'] = array(
    'label' => t('Query notification state'),
    'metadata controller class' => FALSE,
    'entity class' => 'QuerySubscription',
    'controller class' => 'EntityAPIController',
    'base table' => 'query_subscription',
    'module' => 'query_subscription',
    'entity keys' => array(
      'id' => 'id',
      'name' => 'id',
    ),
  );
  return $info;
}

function query_subscription_entity_info_alter(&$info) {
  // Fix broken query url
  $info['mica_query']['uri callback'] = '_query_subscription_query_url';
}

function _query_subscription_query_url($query) {
  return array('path' => "node/{$query->dataset_id}/queries/{$query->id}",
    'options' => array());
}

// implements hook_cron
function query_subscription_cron() {
//  $r = _query_subscription_query_result(array_pop(entity_load('mica_query', array(24))));
//  return;

  $result = db_query(
    "select n.id, q.user_id from {query_subscription} n join {mica_query} q on n.query_id = q.id
      where (
        n.updated is NULL
        or (n.poll_interval = 1 and :now - 86400 > n.updated)   -- daily
        or (n.poll_interval = 2 and :now - 604800 > n.updated)  -- weekly
        or (n.poll_interval = 3 and :now - 2592000 > n.updated) -- monthly
        or n.poll_interval = 4
      )
      group by q.user_id",
    array(':now' => REQUEST_TIME))->fetchAllKeyed();

  $queue = DrupalQueue::get('query_subscription');

  // Create one job per uid so we can send each user one email
  $uidmap = array();
  foreach($result as $id => $uid) {
    $uidmap[$uid][] = $id;
  }
  foreach($uidmap as $uid => $ids) {
    $queue->createItem(array($uid, $ids));
  }
}

// implements hook_cron_queue_info
function query_subscription_cron_queue_info() {
  return array('query_subscription' => array(
    'worker callback' => '_query_subscription_poll',
    'time' => 1800,
  ));
}

// implements hook_entity_delete
function query_subscription_entity_delete($entity, $type) {
  if($type !== 'mica_query') return;

  $notify_state = QuerySubscription::getForQuery($entity);
  if($notify_state) {
    $notify_state->delete();
  }
}


// Implements hook_form_FORM_ID_alter
function query_subscription_form_mica_query_edit_form_alter(&$form, &$form_state, $form_id) {
  $default = FALSE;
  if(isset($form_state['build_info']['args'][1])) {
    $default = QuerySubscription::hasNotification($form_state['build_info']['args'][1]);
  }

  // Define a new button to update inherited fields
  $notify_field = array(
    '#type' => 'checkbox',
    '#title' => t("Notify on result changes"),
    '#default_value' => $default,
  );

  $form['general']['receive_notifications'] = $notify_field;
  $form['#submit'][] = 'query_subscription_save_submit_handler';
}

function query_subscription_save_submit_handler($form, &$form_state) {


  $a = 1;

}

// implements hook_form_FORM_ID_alter
function query_subscription_form_mica_query_run_page_alter(&$form, &$form_state, $form_id) {
  $query = $form_state['mica']['query'];

  $form['notify'] = array(
    '#type' => 'submit',
    '#prefix' => '<br>',
  );

  if(QuerySubscription::hasNotification($query)) {
    $form['notify'] += array(
      '#value' => t('Unsubscribe from change notification'),
      '#submit' => array('query_subscription_unsubscribe'),
    );
  } else {
    $form['notify'] += array(
      '#value' => t('Subscribe to change notification'),
      '#submit' => array('query_subscription_subscribe'),
    );
  }

  drupal_set_message(serialize(drupal_cron_run()));
}

function query_subscription_subscribe($form, &$form_state) {
  $query = $form_state['mica']['query'];

  $notification_state = new QuerySubscription($query);
  $notification_state->save();
}

function query_subscription_unsubscribe($form, &$form_state) {
  $query = $form_state['mica']['query'];
  $notify_state = QuerySubscription::getForQuery($query);
  if($notify_state) {
    $notify_state->delete();
  }
}

function _query_subscription_poll($arg) {
  //echo "running job\n";

  list($uid, $ids) = $arg;

  $user = user_load($uid);
  $old_user = $GLOBALS['user'];

  $changed = array();

  try {
    $GLOBALS['user'] = $user;

    foreach ($ids as $id) {
      $subscription = QuerySubscription::get($id);
      if (is_null($subscription)) continue;

      $differences = $subscription->getSignificantDifferences();

      if (!empty($differences)) {
        $changed[] = array(
          'differences' => $differences,
          'descriptors' => $subscription->descriptors(),
          'subscription' => $subscription
        );
      }
    }

    if (!empty($changed)) {
      _query_subscription_email($uid, $changed);
    }

  // poor mans finally
  } catch (Exception $e) {
    $GLOBALS['user'] = $old_user;
    throw $e;
  }
  $GLOBALS['user'] = $old_user;

}


function _query_subscription_query_result($query) {
  $connectors = mica_connector_query_multiple($query->dataset_id);

  $fullresult = array();
  foreach($connectors as $connector) {

    $terms = mica_query_term_query($query);
    $cross_variable = node_load($query->cross_variable_id);

    if(empty($cross_variable)) {
      $result = $connector->query($terms);
      unset($result['_all']);
    } else {
      $result = $connector->queryBy($terms, array($cross_variable->title));
      // Depending on if it is a cross query use '_all' or 'total', unset the other.
      // I'm not sure why this difference exists, but this is what the display code uses.
      unset($result['total']);
    }

    $fullresult[$connector->id] = $result;
  }
  return $fullresult;
}


class QuerySubscription extends Entity {

  public $id = NULL;
  public $query_id = NULL;
  public $poll_interval = self::ALLWAYS;
  public $threshold = 0.05;
  public $updated = NULL;
  public $last_result = NULL;

  const DAILY = 1;
  const WEEKLY = 2;
  const MONTHLY = 3;
  const ALLWAYS = 4;

  const QS = 'query_subscription';


  public function __construct($arg = array()) {
    if(is_a($arg, 'MicaDatasetQuery')) {
      $arg = array('query_id' => $arg->id);
    }
    if(array_key_exists('query', $arg)) {
      $arg['query_id'] = $arg['query']->id;
      unset($arg['query']);
    }
    if(isset($arg['updated']) && is_object($arg['updated'])) {
      $arg['updated'] = $arg['updated']->getTimestamp();
    }
    parent::__construct($arg, self::QS);
  }

  /**
   * Get a QuerySubscription
   * @param $id Numeric entity ID
   * @return QuerySubscription|null
   */
  public static function get($id) {
    $subscription = entity_load(self::QS, array($id));
    if(empty($subscription)) { return NULL; }
    return array_pop($subscription);
  }

  public static function hasNotification($query) {
    $count = db_query("select count(*) from {query_subscription} where query_id = :qid",
      array(':qid' => $query->id))->fetchField();
    return (bool) $count;
  }

  public static function getForQuery($query) {
    $id = db_query("select id from {query_subscription} where query_id = :qid",
      array(':qid' => $query->id))->fetchField();
    if(is_null($id)) return NULL;
    return self::get($id);
  }

  /**
   * @return MicaDatasetQuery
   */
  public function query() {
    // entity_load already caches
    $q = entity_load('mica_query', array($this->query_id));
    if(empty($q)) throw new Exception("mica_query entity for query_subscription not found");
    return array_pop($q);
  }

  public function updated() {
    $d = new DateTime();
    $d->setTimestamp($this->updated);
    return $d;
  }

  private function needsUpdate() {
    if(is_null($this->updated)) return TRUE;
    switch($this->poll_interval) {
      case self::DAILY:
        return $this->updated < time() - 60*60*24;
      case self::WEEKLY:
        return $this-> updated < time() - 60*60*24*7;
      case self::MONTHLY:
        return $this-> updated < time() - 60*60*24*30;
      case self::ALLWAYS:
        return TRUE;
      default:
        throw new Exception("Unknown poll_interval value: {$this->poll_interval}, must be in range 1-3");
    }
  }

  public function getSignificantDifferences() {
    if(!$this->needsUpdate()) return array();

    $new_result = $this->getResults();

    if(is_null($this->updated) || is_null($this->last_result)) {
      $this->update($new_result);
      return array();
    }

    $old_result = unserialize($this->last_result);

    $changed = array();
    if(!$this->_recursiveCompare($old_result, $new_result, array('connection', 'term', 'category'), $changed)) {
      $this->update($new_result);
      return array();
    }

    return $changed;
  }
  /* document return value / $changed */
  private function _recursiveCompare($old, $new, $names, &$changed, $path = array()) {
    if (count($names) == 0) {
      $diff = $old * $this->threshold;
      if ($new > $old + $diff || $new < $old - $diff) {
        $changed[] = $path + array('old_value' => $old, 'new_value' => $new);
      }
    } else {
      $keyname = array_shift($names);
      if (count($old) != count($new)) return FALSE;
      foreach ($old as $key => $old_value) {
        if (!isset($new[$key])) return FALSE;
        $ret = $this->_recursiveCompare($old_value, $new[$key], $names, $changed, $path + array($keyname => $key));
        if (!$ret) return FALSE;
      }
    }
    return TRUE;
  }

  public function descriptors() {
    $query = $this->query();

    $ret = array();
    $ret['connectors'] = self::id_map(mica_connector_query_multiple($query->dataset_id));
    $ret['terms'] = mica_query_term_query($query);
    $ret['dataset'] = self::metaload($query->dataset_id);

    $ret['studies'] = array();
    foreach($ret['connectors'] as $connid => $conn) {
      $ret['studies'][$connid] = self::metaload($conn->study_id);
    }

    $ret['term_variables'] = array();
    foreach ($ret['terms'] as $tid => $term) {
      $ret['term_variables'][$tid] = self::metaload($term->variable_id);
    }
    $ret['cross_variable'] = self::metaload($query->cross_variable_id);

//    $categories = array('_all' => 'total', 'total' => 'total', '_matched' => 'matched');
    $ret['categories'] = array();
    if ($ret['cross_variable']) {
      foreach (entity_metadata_wrapper('node', $ret['cross_variable'])->field_variable_categories->value() as $cat) {
        $ret['categories'][$cat['name']] = $cat['label'];
      }
    }

    return $ret;
  }

  private function update($new_result) {
    $this->updated = time();
    $this->last_result = serialize($new_result);
    $this->save();
  }

  public function getResults() {
    return _query_subscription_query_result($this->query());
  }


  private static function id_map($arr) {
    $ret = array();
    foreach($arr as $item) {
      $ret[$item->id] = $item;
    }
    return $ret;
  }

  private static function metaload($id) {
    //return entity_metadata_wrapper('node', node_load($id));
    return node_load($id);
  }

}
