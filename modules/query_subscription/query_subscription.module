<?php

require_once 'query_subscription.email.inc';
require_once 'query_subscription.entity.inc';

// implements hook_entity_info
function query_subscription_entity_info() {
  $info = array();
  $info['query_subscription'] = array(
    'label' => t('Query notification state'),
    'metadata controller class' => FALSE,
    'entity class' => 'QuerySubscription',
    'controller class' => 'EntityAPIController',
    'base table' => 'query_subscription',
    'module' => 'query_subscription',
    'entity keys' => array(
      'id' => 'id',
      'name' => 'id',
    ),
  );
  return $info;
}

function query_subscription_entity_info_alter(&$info) {
  // Fix broken query url
  $info['mica_query']['uri callback'] = 'query_subscription_query_url';
}

// Replacement as the default from module mica_query is broken
function query_subscription_query_url($query) {
  return array('path' => "node/{$query->dataset_id}/queries/{$query->id}",
    'options' => array());
}

// implements hook_cron
function query_subscription_cron() {
//  $r = query_subscription_query_result(array_pop(entity_load('mica_query', array(24))));
//  return;

  $result = db_query(
    "select n.id, q.user_id from {query_subscription} n join {mica_query} q on n.query_id = q.id
      where (
        n.updated is NULL
        or  n.poll_interval = ".QuerySubscription::ALWAYS."                                  -- always
        or (n.poll_interval = ".QuerySubscription::DAILY."   and :now - 86400 > n.updated)   -- daily
        or (n.poll_interval = ".QuerySubscription::WEEKLY."  and :now - 604800 > n.updated)  -- weekly
        or (n.poll_interval = ".QuerySubscription::MONTHLY." and :now - 2592000 > n.updated) -- monthly
      )
      group by q.user_id",
    array(':now' => time()))->fetchAllKeyed();

  $queue = DrupalQueue::get('query_subscription');

  // Create one job per uid so we can send each user one email
  $uidmap = array();
  foreach($result as $id => $uid) {
    $uidmap[$uid][] = $id;
  }
  foreach($uidmap as $uid => $ids) {
    $queue->createItem(array($uid, $ids));
  }
}

// implements hook_cron_queue_info
function query_subscription_cron_queue_info() {
  return array('query_subscription' => array(
    'worker callback' => 'query_subscription_poll',
    'time' => 1800,
  ));
}

// implements hook_entity_delete
function query_subscription_entity_delete($entity, $type) {
  if($type !== 'mica_query') return;

  $notify_state = QuerySubscription::getForQuery($entity);
  if($notify_state) {
    $notify_state->delete();
  }
}


// Implements hook_form_FORM_ID_alter
function query_subscription_form_mica_query_edit_form_alter(&$form, &$form_state, $form_id) {
  $subscription = NULL;
  if(isset($form_state['build_info']['args'][1])) {
    $subscription = QuerySubscription::getForQuery($form_state['build_info']['args'][1]);
    $active = TRUE;
  }
  if(is_null($subscription)) {
    $subscription = new QuerySubscription();
    $active = FALSE;
  }

  // Define a new button to update inherited fields
  $xtra_fields = array(
    'notify_enabled' => array(
      '#type' => 'checkbox',
      '#title' => t("Receive notification of changes"),
      '#default_value' => $active,
      '#description' => t("When enabled, you will receive email notifications if the result of the query changes. This requires that the query is saved."),
    ),

    'notify_interval' => array(
      '#type' => 'select',
      '#title' => t("Send notifications at most every..."),
      '#options' => array(
        QuerySubscription::DAILY => 'day',
        QuerySubscription::WEEKLY => 'week',
        QuerySubscription::MONTHLY => 'month',
      ),
      '#default_value' => $subscription->poll_interval,
      '#states' => array(
        // Only show this field when the notify_enabled checkbox is checked.
        'visible' => array(':input[name="notify_enabled"]' => array('checked' => TRUE)),
      ),
    ),

    'notify_threshold' => array(
      '#type' => 'textfield',
      '#title' => t("Notification threshold"),
      '#default_value' => $subscription->threshold * 100,
      '#field_suffix' => '%',
      '#size' => 2,
      '#element_validate' => array('query_subscription_validate_percentage'),
      '#description' => t("You will only receive a notification if at least one of the result values differs with at least this percentage from its previous value"),
      '#states' => array(
        // Only show this field when the notify_enabled checkbox is checked.
        'visible' => array(':input[name="notify_enabled"]' => array('checked' => TRUE)),
      ),
    ),
  );

  $form['general'] += $xtra_fields;
  $form['#submit'][] = 'query_subscription_save_submit_handler';
  // Disable 'run' option without save if notification is selected
  if(isset($form['actions']['run'])) {
    if (!isset($form['actions']['run']['#states'])) {
      $form['actions']['run']['#states'] = array();
    }
    $form['actions']['run']['#states']['disabled'] = array(':input[name="notify_enabled"]' => array('checked' => TRUE));
  }
}

function query_subscription_validate_percentage($field) {
  $value = (float) str_replace(',', '.', trim($field['#value']));
  return preg_match('/^\d+((,|\.)\d+)?$/', trim($field['#value'])) === 1 &&
    $value >= 0;
}

function query_subscription_save_submit_handler($form, &$form_state) {
  if($form_state['clicked_button']['#id'] != 'edit-save') return;

  if(isset($form_state['build_info']['args'][1])) {
    $query = $form_state['build_info']['args'][1];
  } else if(isset($form_state['redirect'])) {
    $query = menu_get_object('mica_query', 3, $form_state['redirect']);
  } else {
    watchdog('query_subscription', 'Unable to retrieve query in subscription edit submit handler', array(), WATCHDOG_ERROR);
    throw new Exception('Unable to retrieve query in subscription edit submit handler');
  }

  $new = FALSE;
  $subscription = QuerySubscription::getForQuery($query);
  if(is_null($subscription)) {
    $subscription = new QuerySubscription(array('query' => $query));
    $new = TRUE;
  }

  if (!$form_state['values']['notify_enabled']) {
    if(!$new) {
      $subscription->delete();
    }
    return;
  }

  if($new ||
      $form_state['values']['notify_interval'] !== $form_state['input']['notify_interval'] ||
      $form_state['values']['notify_threshold'] !== $form_state['input']['notify_threshold']) {
    // something changed
    $subscription->poll_interval = $form_state['values']['notify_interval'];
    $subscription->threshold = ((float) str_replace(',', '.', trim($form_state['values']['notify_threshold']))) / 100;
    $subscription->save();
  }
}

// implements hook_form_FORM_ID_alter
function query_subscription_form_mica_query_run_page_alter(&$form, &$form_state, $form_id) {
  $query = $form_state['mica']['query'];

  $form['notify'] = array(
    '#type' => 'submit',
    '#prefix' => '<br>',
  );

  if(!empty($query) && QuerySubscription::hasNotification($query)) {
    $form['notify'] += array(
      '#value' => t('Unsubscribe from change notification'),
      '#submit' => array('query_subscription_unsubscribe'),
    );
  } else {
    $form['notify'] += array(
      '#value' => t('Subscribe to change notification'),
      '#submit' => array('query_subscription_subscribe'),
    );
  }

  //drupal_set_message(serialize(drupal_cron_run()));
}

function query_subscription_subscribe($form, &$form_state) {
  $query = $form_state['mica']['query'];

  $notification_state = new QuerySubscription($query);
  $notification_state->save();
}

function query_subscription_unsubscribe($form, &$form_state) {
  $query = $form_state['mica']['query'];
  $notify_state = QuerySubscription::getForQuery($query);
  if($notify_state) {
    $notify_state->delete();
  }
}

function query_subscription_poll($arg) {
  list($uid, $ids) = $arg;

  $user = user_load($uid);
  if(empty($user)) {
    watchdog('query_subscription', 'Attempting to check for query changes for non-existing user, uid @uid', array('@uid' => $uid), WATCHDOG_WARNING);
    return;
  }

    $changes = array();

  // Some mica functions don't support passing a user object, they always use the global user so we set that
  $old_user = $GLOBALS['user'];
  try {
    $GLOBALS['user'] = $user;

    foreach ($ids as $id) {
      $subscription = QuerySubscription::get($id);
      if (is_null($subscription)) continue;

      $differences = $subscription->significantDifferences();

      if (!empty($differences)) {
        $changes[] = array(
          'differences' => $differences,
          'subscription' => $subscription
        );
      }
    }

    if (!empty($changes)) {
      drupal_mail('query_subscription', 'notification', $user->mail, $user->language,
        array('user' => $user, 'changes' => $changes));
    }

  // poor mans finally
  } catch (Exception $e) {
    $GLOBALS['user'] = $old_user;
    throw $e;
  }
  $GLOBALS['user'] = $old_user;

}


function query_subscription_query_result($query) {
  $connectors = mica_connector_query_multiple($query->dataset_id);

  $fullresult = array();
  foreach($connectors as $connector) {

    $terms = mica_query_term_query($query);
    $cross_variable = node_load($query->cross_variable_id);

    if(empty($cross_variable)) {
      $result = $connector->query($terms);
      unset($result['_all']);
    } else {
      $result = $connector->queryBy($terms, array($cross_variable->title));
      // Depending on if it is a cross query use '_all' or 'total', unset the other.
      // I'm not sure why this difference exists, but this is what the display code uses.
      unset($result['total']);
    }

    $fullresult[$connector->id] = $result;
  }
  return $fullresult;
}

